# 함수 동작 원리

모든 프로그래밍 언어에는 함수가 존재합니다.  
`main` 함수 예문을 경험해서 아시겠지만 함수의 기본형은 아래와 같이 생겼습니다.

```rs
fn main() {
  println!("Hello world!");
}
```

## 매개변수

함수 내부에서 적절한 처리를 하기 위해 함수는 매개변수를 받을 수 있습니다.

```rs
fn sum(a: i32, b: i32) -> i32 {
  a + b
}
```

위 함수는 `a + b`를 반환하기에 반환 타입을 `-> i32` 와 같이 설정할 필요가 있습니다.

## 구문과 표현식

### 구문

구문은 어떠한 명령들로 이루어진 **값을 반환하지 않는** 성격을 가지고 있습니다.

아래 예문을 봅시다.

```rs
fn main() {
  let x = let y = 0;
}
```

이 함수는 컴파일 시 오류가 발생합니다.  
대입 연산자 이후에 작성 된 `let y = 0` 은 구문이므로 값을 반환하지 않기에 `x` 에 대입할 값이 없기 때문입니다.

일부 다른 언어에서는 `x = y = 6` 과 같은 표현식으로 `x`와 `y`를 동시에 선언할 수 있지만 Rust는 불가능합니다.

### 표현식

구문과는 반대로 표현식은 **값을 반환**합니다.  
Rust는 대부분 표현식으로 이루어져 있습니다.

함수를 '호출'하거나, `{}` 으로 새로운 범위를 설정하는 모든 행위는 표현식에 해당합니다.

```rs
{
    let x = 3;
    x + 1
}
```

위 블럭은 `4`를 반환하게 되는 표현식입니다.

위 표현식에서 한가지 주의할 점은 **마지막 줄에 세미콜론으로 종결을 짓지 않았다**는 점입니다.  
표현식은 세미콜론을 사용하지 않으며, 세미콜론을 사용하게 되면 이는 표현식이 아닌 구문으로 변환 됩니다.

## 반환 값이 있는 함수

```rs
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

위 코드는 `The value of x is: 5`를 출력합니다.  
`five` 함수는 `5`를 반환하기에 `let x = 5;` 가 되었기 때문입니다.

이처럼 함수를 실행할 때 값을 반환하게 구현할 수 있는데, 이럴 경우 함수의 가장 마지막 표현식에는 `;` 가 포함되지 않아야 합니다.
이게 Rust에서의 Return 방식입니다.

```rs
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```

위 코드는 `plus_one` 함수의 표현식에 세미콜론을 추가한 형태입니다.  
이럴 경우 컴파일러는 컴파일에 실패하게 됩니다.

왜냐하면, `plus_one` 함수의 반환 값을 `i32`라고 규정했으나 `x + 1` 표현식에 세미콜론이 붙어 구문으로 변환 되었기에 이는 더 이상 값을 반환하지 않기 때문입니다.
