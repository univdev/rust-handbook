# 변수와 가변성

## 불변성

Rust에서 선언하는 변수는 기본적으로 *불변성*을 갖고 있습니다.  
이는 안정성과 동시성을 얻기 위해 Rust에서 강제하는 요소입니다.

Rust에서의 변수 선언은 `let` 키워드로 수행하는데, 일반적으로 아래와 같이 선언합니다.

```rs
let num = 3;
println!("num is {}", num);
```

다만 아까도 얘기 했듯이 변수는 기본적으로 불변이기에 값을 바꿀 수 없습니다.

```rs
let num = 3;
num = 42; // re-assignment of immutable variable `num`
```

이 코드를 실행하면 컴파일 오류가 발생합니다.

## 가변성

모든 변수를 불변하게 작성할 수는 없으니 가변성에 대해서도 알아봐야 합니다.  
방법은 간단합니다.

변수를 선언할 때 `mut` 접두어를 붙이면 됩니다.  
이런 식으로요.

```rs
let mut num = 3;
mut = 42;
```

위 코드는 컴파일을 실패하지 않습니다.

## 상수

정말 놀랍게도 '불변성' 개념이 있는 Rust에서도 상수는 존재합니다.  
상수는 말 그대로 '변하지 않는 값'을 의미합니다.

그렇다면 왜 불변성 변수를 냅두고 상수라는 개념을 추가했을까요?
왜냐하면 변수에서의 불변성은 *한가지 옵션*일 뿐이기 때문입니다.  
`mut` 키워드를 통해 얼마든지 가변성 변수가 될 수 있고 이는 프로그램의 수정 여부에 따라 달라질 수 있습니다.

하지만 상수는 **불변성 그 자체**이기에 한번 선언 된 상수는 컴파일 과정에서 고정되고 런타임 도중에 바뀌지 않습니다.  
상수를 선언하기 위해서는 두가지 규칙만 준수하면 됩니다.

- `const` 키워드를 사용할 것
- 상수의 이름은 대문자로 지을 것

```rs
const MAX_HP: u32 = 100_000;
```

이런식으로요.

프로그램 전역에 공통적으로 사용하는 값을 상수로 선언하면 이후 수정 및 관리가 용이해지고 단순 `100000`이라고 하드코딩 하는 것 보다 같이 작업하는 분들이 이해하기 쉽습니다.

## Shadowed

많은 프로그래밍 언어에서는 동일한 이름의 변수를 재선언 하는 것을 허용하지 않습니다.  
하지만 Rust에서는 가능합니다.  
Rust에서는 이러한 동작을 `Shadowing` 이라고 부릅니다.

```rs
let x = 3;
let x = x + 2;
let x = x * 2;

println!("x is {}", x);
```

위 코드는 실행하면 `10`이 보여지게 됩니다.

1. `x`의 값을 3으로 정의합니다. (3)
2. `x`의 기존 값을 그대로 넘겨받아 2를 더한 값으로 `x` 변수를 재선언 합니다. (3 -> 5)
3. `x`의 기존 값을 그대로 넘겨받아 2를 곱한 값으로 `x` 변수를 재선언 합니다. (5 -> 10)
4. 최종 출력문에는 `x is 10` 이 나오게 됩니다.

`Shadowing`이 `mut`과 다른 점은 변수를 재선언한 이후에는 불변성을 그대로 가져간다는 것입니다.  
`let mut`으로 선언한 변수는 끝까지 가변성이지만 `let`으로 선언하면 불변성을 가진 변수로 생겨나기 떄문입니다.

이 특징을 활용할 수 있는 예시가 있습니다:

```rs
let spaces = "   ";
let spaces = spaces.len();
```

위 코드는 '공백문자의 갯수'를 구하는 코드입니다.  
만약 `Shadowing`이 없었다면 `spaces_len` 혹은 `spaces_count` 등의 이름을 가진 새 변수를 생성해야 했을 것입니다.

추가로, 이 과정에서 `mut` 접두어를 사용해서 `spaces`를 생성했다면 어떻게 될까요?

```rs
let mut spaces = "   ";
spaces = spaces.len();
```

이 코드는 오류가 발생하게 됩니다.  
기본적으로 문자열 타입으로 생성 된 `spaces` 변수에 숫자형 값을 삽입하고 있기 때문입니다.
