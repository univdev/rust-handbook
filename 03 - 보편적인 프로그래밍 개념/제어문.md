# 제어문

제어문은 프로그램의 동작을 제어하기 위해 사용 됩니다.

## 조건문

다른 프로그래밍에서 _if문_ 이라고 자주 불리는 그거 맞습니다.  
Rust에서의 조건문은 다음과 같이 사용합니다.

```rs
fn main() {
  let is_true = true;

  if is_true {
    println!("Hello world!");
  }
}
```

그렇다면 이제 다음을 봅시다.

```rs
fn main() {
  let number = 3;

  if number {
    println!("number is three");
  }
}
```

이 코드는 컴파일 시 에러가 발생합니다.  
왜냐하면 `if`문의 조건식에는 `bool`을 반환하는 표현식이 등장해야 하기 때문입니다.  
이 부분에서 Javascript나 Python과는 다르게 동작하는데, Rust는 조건식에 들어오는 다른 타입의 값을 `bool` 값으로 변환 해주지 않습니다.  
그래서 위 코드를 정상 동작하게 하려면 다음과 같이 수정해야 합니다.

```rs
fn main() {
  let number = 3;

  if number == 3 {
    println!("number is three");
  }
}
```

```rs
fn main() {
  let number = 3;

  if number == 3 {
    println!("number is three");
  } else if number == 4 {
    println!("number is four");
  } else {
    println!("I dont know value of number");
  }
}
```

이런 식으로 `else if`와 `else`도 사용할 수 있습니다.

## 응용

_함수 동작 원리_ 문서에서 나온 '표현식'의 개념에 대해 다시 한번 상기하며 아래 코드를 봅시다.

```rs
fn main() {
  let condition = true;
  let num = if condition {
    5
  } else {
    6
  };

  println!("num is {}", num);
}
```

위 코드를 실행하면 `num`에 들어가는 값은 `5`가 됩니다.  
표현식에 대해 설명할 때 언급했듯이 `{}` 은 값을 반환하는 표현식입니다.  
그렇기에 변수를 선언할 때 조건문을 사용하게 되면 `{}` 에서 반환하는 값이 해당 변수의 값으로 할당 됩니다.

## 반복문

다른 프로그래밍에도 있는 그거 맞습니다.  
Rust에는 `for` `while` `loop` 세가지 반복문이 존재합니다.

```rs
loop {
  println!("Hello world!");
}
```

위 코드를 실행하면 강제 종료하기 전 까지는 계속 동일한 문장이 출력 됩니다.  
이 경우 `break`를 호출하여 반복문을 빠져나오도록 구현할 수 있습니다.  
그래서 대부분의 경우 `loop`만을 단독 사용하지 않고 조건문과 `break`문을 결합하여 적절한 시기에 빠져나올 수 있도록 프로그램을 설계합니다.
이러한 케이스는 **매우 보편적**이기 때문에 Rust에서는 `while`문으로 이 과정을 추상화 하였습니다.

```rs
fn main() {
  let mut condition = 1;

  while condition < 5 {
    println!("condition is {}", condition);
    condition = condition + 1;
  }
}
```

위 코드는 `condition`이 1, 2, 3, 4로 점진적으로 늘어나다가 5를 출력하지 않고 끝나는 프로그램입니다.  
`while`문은 뒤에 적힌 조건식이 참을 추론할 때만 코드 블럭이 실행 됩니다.  
그렇기에 마지막 코드 실행에서 `5`가 될 경우 `5`와 `condition`의 값이 같아지기에 `5`가 출력되지 않는 것입니다.

심화 된 예시를 한번 더 보겠습니다.

```rs
fn main() {
  let arr = [1, 2, 3, 4, 5];
  let mut index = 0;

  while index < 5 {
    println!("value is {}", arr[index]);
    index = index + 1;
  }
}
```

위 함수는 `arr`을 끝까지 순회하면서 값을 출력합니다.  
하지만 이렇게 사용 하는 것을 권장하지는 않습니다.  
왜냐하면 배열의 사이즈를 잘못 기재할 경우 잘못된 색인이 발생할 수 있는 위험이 있고, **느립니다.**

`while`문은 코드 블럭을 실행하고나서 다음 실행 시 조건식을 재비교 하기 때문에 연산 비용이 비쌉니다.  
이 방식의 대안으로 나온 것이 `for`문입니다.

```rs
fn main() {
  let arr = [1, 2, 3, 4, 5];

  for element in arr.iter() {
    println!("value is {}", element);
  }
}
```

위와 같은 방식으로 배열을 정확하게 탐색하도록 색인의 오류를 방지하였습니다.  
이처럼 반복 횟수를 _명확하게 정의 가능한_ 경우 `for`문을 주로 사용하게 됩니다. 더 효율적이니까요.

기본 라이브러리의 `Range`를 사용하여 n부터 m까지의 반복을 진행할 수도 있습니다.

```rs
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }
    println!("LIFTOFF!!!");
}
```

`.rev()`는 앞에 나온 `Range`가 반환하는 범위를 역순으로 정렬하는 함수입니다.  
`Range`는 `n`부터 `m - 1` 까지의 숫자를 담은 컬렉션을 반환하기 때문에 위 코드를 실행하면

```
3!
2!
1!
LIFTOFF!!!
```

가 출력됩니다.
