# 데이터 타입

대부분의 프로그래밍 언어에서 그렇듯이 변수는 저마다 값을 저장할 수 있는 타입을 갖게 됩니다.
변수는 크게 스칼라와 컴파운드로 나뉩니다.

## Rust의 타입은 불변

Rust는 일부 동적 타입을 지원하는 언어와 다르게 모든 변수의 타입은 **선언 즉시 고정** 됩니다.  
이는 바뀔 수 없다는 점을 명심해야 합니다.

## 스칼라

스칼라는 일반적인 프로그래밍 언어에서 볼 수 있는 기본 자료형인 정수, 부동소수점, 문자, 불리언을 의미합니다.

## 정수

정수는 C언어를 해봤다면 이해가 쉽습니다.  
요즘 프로그래밍 언어는 '숫자' 라는 타입으로 뭉뚱 그리는 경우가 많은데, 저레벨 언어는 **소수점을 보관할 수 있는 타입과 그렇지 않은 타입이 명확하게 나뉩니다.**  
C언어에서는 흔히 Integer(Int) 타입과 Float 타입을 대표적으로 사용합니다.

Rust에서는 정수를 보관할 수 있는 타입이 10개나 됩니다.  
하지만 쓰임이 크게 다르진 않고 단순히 표현 범위의 차이입니다.

| Length | Signed | Unsigned |
| ------ | ------ | -------- |
| 8-bit  | i8     | u8       |
| 16-bit | i16    | u16      |
| 32-bit | i32    | u32      |
| 64-bit | i64    | u64      |
| arch   | isize  | usize    |

`Signed`와 `Unsigned`는 음수의 표현 가능 여부에 있습니다.  
`i`나 `u` 뒤에 들어오는 n값은 해당 타입이 차지하게 되는 메모리의 비트 수입니다.

예를 들어, `i8`의 경우는 메모리에서 8bit 만큼의 공간을 차지하는 정수 변수라는 의미입니다.  
8개의 비트로 이루어져 있으니 i8의 표현 범위는 2^8 이므로 256가지의 경우를 표현하며, -127 ~ 126 사이의 숫자를 저장할 수 있다는 얘기입니다.

`u8` 역시 `i8`과 마찬가지로 8bit의 표현 범위를 가지지만 음수의 표현이 불가능한 변수 타입입니다.  
음수로 할당해야 하는 메모리 공간을 모두 양수에게 할당하기에 `u8`의 표현 범위는 0 ~ 255가 됩니다.

어렵게 생각하지 마시고 여러분이 게임을 만든다고 가정했을 때 아이템을 어떻게 둘러도 공격력 수치가 255를 넘지 않을 것 같으면 `u8`을 사용하면 됩니다.  
공격력 같은 수치는 대부분의 경우 음수를 가지지 않기 때문에 `i8` 대신 `u8`을 사용합니다.

이렇게 명확한 경우가 아니라 얼마나 커질지, 음수 표현이 필요한지도 감이 안잡힌다면 그냥 `i32`를 쓰면 좋습니다.  
`i32`는 Rust의 기본 타입이기도 하고 _64bit 운영체제 환경에서도 속도가 빠릅니다._

> 추가로, `isize`와 `usize`는 일부 콜렉션 타입의 색인에서 사용하게 되는데 만약 프로그램을 실행하는 환경이 64bit 운영체제라면 i64가, 32bit 운영체제 환경이라면 i32가 할당됩니다.

## 부동 소수점

소수점을 표현 가능한 타입은 두 가지로, `f32`와 `f64`입니다.  
기본 타입은 `f64`인데, 최신 CPU 상에서 `f32`랑 속도도 비슷한데 표현 범위는 더 넓기 떄문입니다.

## 불리언

불리언은 더 설명할 것도 없이 `true` 와 `false`를 의미합니다.

```rs
const I_AM_GENIUS: bool = true;
```

이렇게 써요.

## 문자

문자 타입은 `char` 타입인데, 문자열과는 다르게 한 글자만 저장할 수 있다는 점을 알아야 합니다.
문자열을 선언할 때는 큰 따옴표를 쓰지만 `char` 타입에 문자를 할당할 때는 작은 따옴표를 씁니다.  
이 부분은 C언어를 학습한 경험이 있다면 친숙할 것입니다.

Rust의 `char` 타입은 Unicode Scalar를 표현하기에 다른 저레벨 언어의 `char` 타입보다 넓은 표현이 가능합니다.

```rs
fn main() {
   let c = 'z';
   let z = 'ℤ';
   let heart_eyed_cat = '😻';
}
```

그 덕분에 이렇게 특수문자나 이모지를 `char` 타입으로 지정하는게 가능합니다. _(심지어 한국어/중국어/일본어도 가능해요)_  
그럼에도 불구하고 문자는 Unicode를 위한 개념이 아니기에 사람이 흔히 표현하는 '문자'와는 다르게 동작할 수도 있습니다.  
이 부분은 이후에 알아봅시다.

## 튜플과 배열

### 튜플

튜플은 복합 타입을 가지고 있는 데이터 유형입니다.  
하나의 튜플에는 반드시 동일한 타입의 값만 저장될 수 있는 것은 아닙니다.

```rs
let tup: (i32, i8, f32) = (3, 5, 8.3);
```

이렇게 여러 타입의 값을 묶어서 저장할 수 있습니다.

또한 구조분해를 통해 새로운 변수를 선언할 수도 있습니다.

```rs
let tup: (i32, i8, f32) = (3, 5, 8.3);
let (a, b, c) = tup; // 각각 a = 3, b = 5, c = 8.3
```

혹은 다른 프로그래밍 언어에서의 배열처럼 인덱스로 색인도 가능합니다.

```rs
let tup: (i32, i8, f32) = (3, 5, 8.3);
let a = tup.0;
let b = tup.1;
let c = tup.2;
```

### 배열

Rust에서의 배열은 일부 프로그래밍 언어와 다르게 반드시 크기가 선언 당시에 고정 됩니다.  
만약 처음 할당했을 때 8개의 사이즈를 갖는 배열을 선언했다면 프로그램이 종료 되기 까지 8칸에서 늘거나 줄지 않습니다.

크기가 확정 되어도 괜찮은 일부의 경우가 아니라면 이후에 등장할 _'벡터' 자료형을 쓰는게 좋습니다._

배열을 사용하는 대표적인 예시는 달력의 달(Month)을 표현하는 경우입니다:

```rs
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

갑자기 인류가 새로운 달을 추가하거나 빼지는 않을테니 배열을 사용하는게 적합합니다.

> 추가적으로, 배열 안에는 반드시 동일한 타입의 값만 삽입 되어야 합니다.

배열 요소에 접근할 때는 이렇게 접근합니다.

```rs
fn main() {
    let a = [1, 2, 3, 4, 5];

    let element = a[0];

    println!("The value of element is: {}", element);
}
```

선언 당시에 확정된 범위 보다 큰 인덱스를 색인하는건 불가능합니다.

```rs
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

이 프로그램은 컴파일 시에 별 문제가 없지만 실행하려고 하면 런타임에서 오류가 발생합니다.  
다른 저수준의 언어는 실제로 참조해선 안되는 메모리 영역임에도 참조를 시도하지만 Rust의 안전장치는 이러한 경우를 만나게 되면 프로그램을 강제 종료하여 사용자를 보호합니다.  
이러한 상황을 보고 *'패닉(Panic)'*이라고 표현합니다.
